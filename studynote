
6-3 自定义authenticate 实现覆盖djago自带的这个方法

1、我们需要先到项目的settings.py里面，加入AUTHENTICATION_BACKENDS = （）这样就会重写后台认证方法
2、我们在View里面，新建一个类， class CustomBackend(ModelBackend),其中ModelBackend为
from django.contrib.auth.backends import ModelBackend
3\ 在这里，我们重写 authenticate,我们先从数据库获取到user:
   user = UserProfile .object.get(Q(username=username) | Q(email = username))
   知识点：Q 为支持并集查询的类，可以从 django.db.models import Q拿到
                  | 这个为查询是否有这个用户名或者邮箱名是这个输入字符
4、然后根据用户名对密码进行验证：
   if user.check_password(password)
   这个时候如果用户名 密码是正确，就返回user,否则就返回None

 6-4 用Class继承view实现登录

1、在实际工作中，我们处理基本用类，不在view里面定义方法，我们接下来就使用 LoginView来替换 login方法
2、我们先引入 from django.views.generic.base import View
3、定义类 Class LoginView (View)来实现对View的继承，同时我们重写了
    def get(self,request):
	doing
    def post(self,request):
      doing
4、我们需要到项目的url文件中，先引入 LoginView，然后 在url映射表中，添加   LoginView.as_view()，记住需要加 () ，因为要获得句柄

6-5用from实现登录

1、定义LoginForm 的类,继承forms里面的Form，需要from django import forms,在LoginForm里面，对应的username password必须和html里面的form名字一直
2、在LoginView里面，定义login_form = LoginForm(request.POST)，这样就把html里面的Form表单的值取到了 login_form里面
3、首先进行login_form.is_valid()，如果数据干净的进行下面逻辑，如果数据不干净会报出错误
4、我们可以用字典直接返回表单的报错，例如
   return render(request,'login.html',{'login_form':login_form})，字典中，前面一个是web使用的参数，后面一个是本次返回的参数
5、在html页面里面我们可以用 {% if login_form.errors.username %}  errorput{%endif%} 来控制当username这个输入框出错时，我们就加一个高亮的显示
6、在html页面里面，有个显示错误的input展示框，我们可以使用
  {% for key,error  in  login_item.errors.items %}
      {{error}}
{% endfor %}来控制具体显示什么错误

7-4 课程机构列表数据展现
1、在具体的展示列表的数据，使用 {% for object in Objects %} 具体代码 {% endfor %}
2、如果在html页面里面实现突破的展示，我么如何将数据库里面的img展示到页面上？
如果需要将后台存储的图片展示到HTML中，需要经过以下步骤：
1. 将image的路径地址 从数据库中 取出来，传递到html中
2. 在settings中配置处理media的templates模板和media路径
3. 配置image的url, 需要import static模块中的serve方法
Setting里面的设置：
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')]
        ,
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
                'django.template.context_processors.media'　　# 1.10版本就是这个media模块  1.9版本是django.core.context_processors.media
            ],
        },
    },
]

MEDIA_URL = "/media/"
MEDIA_ROOT = os.path.join(BASE_DIR, "media")
urls.py中的配置
该url专门处理media路径访问
from django.views.static import serve
url(r'^media/(?P<path>.*)/$', serve, {"document_root": MEDIA_ROOT}),

7-5 实现页面的分页
 1、先安装pip install django-pure-pagination
 2、根据他的教程，把pure-pagination加入到app里面
 3、在view里面 ，引入包里面几个View，
 4、view实现如下代码
           try:
            page = request.GET.get('page', 1)
        except PageNotAnInteger:
            # If page is not an integer, deliver first page.
            page = 1
        paginator = Paginator(all_courseorg, 5, request=request)  # 获取一共有多少个页面
        all_orgs = paginator.page(page)  # 拿到指定的分页
 5、在html里面，加入代码，实现分页
                             {% if all_orgs.has_previous %} #如果 有上一页，那么久显示上一页
                                <li class="long"><a href="?{{ all_orgs.previous_page_number.querystring }}">上一页</a></li>
                            {% endif %}

                            {% for page in all_orgs.pages %}  便利all_orgs里面的分解，并列出来，如果当前页数和服务器页数一直，增加active
                                {% if page %}
                                    {% ifequal page all_orgs.number %}
                                        <li class="active"><a href="?{{ page.querystring }}">{{ page }}</a></li>
                                    {% else %}
                                        <li><a href="?{{ page.querystring }}" class="page">{{ page }}</a></li>
                                    {% endifequal %}
                                {% else %}
                                    <li class="none"><a href="">...</a></li>
                                {% endif %}
                            {% endfor %}

                            {% if all_orgs.has_next %} 如果有下一个，列出下一页
                                <li class="long"><a href="?{{ all_orgs.next_page_number.querystring }}">下一页</a></li>
                            {% endif %}

7-7 url的分发机制

1、进入到项目的url文件，配置url文件如下：
    url(r'^org/', include('organization.urls', namespace='org')),
   其中org为url列表第一条访问信息，后面include 第一个参数，为要定位的 app里面的url，namespace是定义的命名空间，这样，找url将只到对应这个命名
   空间的app里面找
2、进入到app里面，创建一个urls.py的文件，引入：
   from django.conf.urls import url, include
    并写入url配置，如下：
urlpatterns = [
    url(r'^list/$', OrgListView.as_view(), name='orglist'),
]
3、进入到html中，这里是base，找到授课机构，在href里面配置{% url 'org:orglist'%}
  这里org是命名的空间，后面的orglist是对应的app里面的name
 这样我们就可以用  /list/list/来访问到这个url了。

 7-8 进行我要学习数据表的提交--ModelForm
 1、如果表单字段和数据库 字段相同，可以直接使用ModeForm，使用方式为
    class Meta:
    model =UserAsk
    fields = ['fileds' , 'field2' ....]
 2、在View里面，可以直接实例化
    useraskform = UserAskForm(request.Post)
    if user_ask_form .is_valid():
       user_ask_form.save()
 3、因为涉及到动态提交，当前页面不刷新，所以使用ajax技术，ajax的脚本如下：
      <script>
        $(function(){
            $('#jsStayBtn').on('click', function(){
                $.ajax({
                    cache: false,
                    type: "POST",
                    url:"{% url 'org:user_ask' %}",
                    data:$('#jsStayForm').serialize(),
                    async: true,
                    success: function(data) {
                        if(data.status == 'success'){
                            $('#jsStayForm')[0].reset();
                            alert("你已提交成功")
                        }else if(data.status == 'fail'){
                            $('#jsCompanyTips').html(data.msg)
                        }
                    },
                });
            });
        })
    </script>
    同时，在view返回的时候不能 直接render,应该返回jaso格式数据，使用的是
     return HttpResponse("{'status':'success','msg':'已经提交成功'}"，content-type='application/json')
    第一个是json格式的数据，第二个是content-type参数
  4、自定义数据校验的时候，我们使用 def clean_arg:的形式，获取表单的数据我们使用  arg = self.cleaned_date['moile'],代码如下：
         def clean_mobile(self):
        ''''
        验证手机号码是否合法,
        自定义的数据验证，必须以clean开头的方法，另外在调用数据采用sele.cleaned_data['arg']形式
        :return:
        '''
        mobile = self.cleaned_data['mobile']
        REGEX_MOBILE = "^1[358]\d{9}$|^147\d{8}$|^176\d{8}$"
        p = re.compile(REGEX_MOBILE)
        if p.match(mobile):
            return mobile
        else:
            raise forms.ValidationError(u'手机号码非法', code='mobile_invalid')
   其中rase是抛出验证的异常信息
 5、 自己写的时候，发生了一个错误，我在url里面，写的 UserAskView.as_view()，没有加后面的()，导致报错 系统只要1个参数，但实际给了2个参数。

 7-8 实现列表详情页

 1、模板导入，观察模板，发现需要重新建立一个新的模板 org_base.html，并将相应的块设置为block
 2、url 配置，因为详情需要url带入参数, url = (r'^org_home/(?p<org_id>\d+)/$' ,OrgHomeView.as_view(),name = org_home)
 3、编写view, a)定义get方法，-->获取org_id，根据org_id 实例一个Org，然后查到Org的所有课程，
     这里因为Course 里面设置了一个course_org的外键，所以从course_org里面，可以使用反向查询，查询方式为
     course_org_conse_set()获得3个课程 用django的 all_course = org.couse_set()[:3]实现
    根据org,获取所有的teacher

 4、